# IsK5AfterContraction

## Задание 
Проверка того, что указаны ребра, после стягивания которых заданный непланарный граф превращается в граф К5.

## Определения и понятия
Определим операцию стягивания ребра следующим образом:
Для ребра _e ∈ E(G)_ через _G·e_ мы обозначим граф,
полученный в результате стягивания ребра _e = xy_. Это означает, что
граф _G · e_ получается из графа _G − x − y_ добавлением новой вершины _w_, которая будет смежна в графе _G · e_ со всеми вершинами графа _G_,
смежными в _G_ хотя бы с одной из вершин _x_ и _y_.

В результате описанной операции концы _x_ и _y_ ребра _e_ стягиваются в
новую вершину _w_. При определенном таким образом стягивании ребра не возникают ни петли, ни кратные рёбра.

![contraction.png](pictures%2Fcontraction.png) <br>

Полный граф — простой неориентированный граф, в котором каждая пара различных вершин соединена одним ребром (смежна).
Через K5 мы будем обозначать полный граф на 5
вершинах.
![K5.png](pictures%2FK5.png) <br>

## Пример
![ex1.png](pictures%2Fex1.png) <br>
*Рёбра, выделенные любым цветом, кроме серого, должны быть стянуты.

## Алгоритм
*Для удобства при стягивании не создаётся новая вершина, один конец стягиваемого ребра заменяется на другой.
1. Если полученный граф содержит меньше 5-ти вершин или меньше 10-ти рёбер, то после стягивания он не может стать К5.
2. На основе полученного графа строим множество вершин и вершин, смежных с ними, и множество рёбер, которые нужно удалить:
	Если ребро помечено любым цветом, кроме серого, добавляем его в множество рёбер, которые нужно удалить.
	Иначе добавляем оба конца ребра в множество вершин и добавляем в множество, соответствующее вершине, смежную вершину.
3. После добавляем в множество вершин те вершины полученного графа, которые ещё не были в него добавлены.
4. В цикле по множеству удалённых рёбер:
	Проверяем, что его концы не являются смежными (это нужно для корректной работы алгоритма при стягивании рёбер с общей вершиной).
	Из множества вершин удаляем один конец, перемещаяя его соседей к другому концу.
	Заменяем номер удалённой вершины на номер той, которой её заменили (как в множестве вершин, так и в множестве удалённых рёбер).
5. Проверяем получившееся множество вершин и вершин, смежных с ними:
	Если в множестве 5 вершин и каждая имеет 4 соседа, то граф является К5 после стягивания рёбер.
	Иначе граф не является К5 после стягивания рёбер.

## Реализация алгоритма
Для хранения вершин и списка смежных с ними используется структура данных *HashMap*:
```Java 
HashMap<UUID, HashSet<UUID>> contractedGraph
```

Написана функция для добавления вершин в это множество:
```Java 
private void AddEdge(UUID fromVertex, UUID toVertex){
        if(contractedGraph.containsKey(fromVertex)) {
            contractedGraph.get(fromVertex).add(toVertex);
        }
        else{
            contractedGraph.put(fromVertex, new HashSet<>());
            contractedGraph.get(fromVertex).add(toVertex);
        }
}
```
Для хранения стягиваемых рёбер используется структура данных *HashSet*:
```Java 
HashSet<Edge> removedEdges
```

Удаление вершины и перемещение её соседей вершине, смежной по стягиваемому ребру:
```Java 
if(contractedGraph.containsKey(fromVertex) && contractedGraph.containsKey(toVertex)) {
	contractedGraph.get(toVertex).addAll(contractedGraph.get(fromVertex));
	contractedGraph.keySet().remove(fromVertex);
}
```

Замена удалённой вершины на смежную ей по стягиваемому ребру:
```Java 
for (var vertex : contractedGraph.keySet()) {
	if(contractedGraph.get(vertex).contains(fromVertex)) {
		contractedGraph.get(vertex).remove(fromVertex);
		contractedGraph.get(vertex).add(toVertex);
		}
}
for (var tmp: removedEdges){
	if(tmp.getFromV().equals(fromVertex)){
		tmp.setFromV(toVertex);
	}
	if(tmp.getToV().equals(fromVertex)){
		tmp.setToV(toVertex);
	}
}
```

Проверка на то, является ли граф К5:
```Java 
if(contractedGraph.size() == 5){
	for(var vertex: contractedGraph.keySet()){
		contractedGraph.get(vertex).remove(vertex);
		if(contractedGraph.get(vertex).size() != 4){
			return false;
		}
	}
	return true;
}
return false;
```