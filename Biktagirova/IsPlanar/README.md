# Является ли граф планарным
```
Романова Ксения 2381
Биктагирова Дарья 2381
```
**Теоретическая справка к модулю:**

Граф планарный, если все его компоненты связности планарные.

Граф является планарным, если его можно разложить на плоскости без пересечения ребер(planar embedding).

 Необходимо 2 леммы, определяещие свойства планарных графов
1. Если граф G планарный, то для него выполняется E < 3V-3 (следствие теоремы Эйлера)
2. Путь граф плоский. Пусть p1, p2, p3 - пути, ведущие из x в y таким образом, у каждого из двух путей общими будут только вершины x и y. Пусть (x, v1), (x, v2), (x, v3) - начальные ребра p1, p2, p3 соответственно, и пусть (w1, y), (w2, y), (w3, y) - последние ребра.
Если ребра начальные ребра расположены по часовой стрелке относительно x в порядке (x, v1), (x, v2), (x, v3), тогда относительно y по часовой стрелке ребра расположены так -  (w1, y1), (w3, y2), (w2, y).
Эта лемма - следствие теоремы Жордана.

Для проверки планарности был реализован алгоритм Хопкрофта-Тарьяна, основанный на модифицированном поиске в глубину(Efficient Planarity Testing, John Hopcroft and Robert Tarjan, Cornell University, Ithaca, New York).
Алгоритм работает за время не большее O(V+E) и требует памяти не больше, чем O(E).

Если G - неориентированный граф, то DFS определяет направление каждого ребра по ходу продвижения вглубь. Получившиеся ребра также разделяем на 2 класса: множество ребер построенного остовного дерева(tree arcs) и ребра, которые были обнаружены ведущими в уже обработанные вершины(fronds).
Для arc (n1,n2) - n1<n2;
Для frond (n1,n2) - n1>n2;
Структура путей в таком дереве достаточно простая: удобно выделять пути, определяющие грани, и "раскладывать" их так, чтобы границы не пересекались.

Далее мы используем алгоритм, который находит цикл(наибольший) в получившемся графе(path) и удаляет его, оставляя множество отдельных частей.Этот алгоритм рекурсивно проверяет планарность каждой части и определяет, можно ли плоское разложение частей объединить так, чтобы получить плоский граф.

После удаления главного цикла, каждый найденный цикл будет состоять из (самонепересекающегося) пути из arc- и frond-ребер, не входящих в удаленный цикл + путь из arc-ребер удаленного цикла.

При первом DFS мы также определяем приоритет ребер для второго прохода DFS(второй проход как раз ищет циклы(пути) и рекурсивно выполняет их плоское разложение). Для этого используются два значения LPT1 и LPT2. Они определяют для каждой вершины графа v вершины с наименьшими номерами, в которые можно попасть из v или ее "детей"(вершины, в которые есть путь из v по arc-ребрам).
При втором DFS, начиная с вершины с наименьшим номером, мы будем знать по каким ребрам идти в приоритете, чтобы получить наибольший цикл(верно для двусвязного графа, в случае связного графа алгоритм может найти несколько циклов и работать внутри них по очереди).

Каждый цикл нам достаточно определять номером вершины, в которую ведет его последнее frond-ребро. По теореме Жордана, каждый такой путь может быть расположен "внутри" или "снаружи" предыдущего цикла. Поэтому в процессе нахождения путей и их раскладки, будем пытаться записывать эти значения сначала во внутренний стек, если в нем уже будут конфликтующие значения, то будем перемещать каждый из конфликтующих циклов "изнутри" "наружу". Если и в этом случае будет возникать конфликт(по факту пересечение) путей, то можем сделать вывод, что граф не планарный.

____
