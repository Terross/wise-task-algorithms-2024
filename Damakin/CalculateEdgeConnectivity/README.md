> Теоретическая справка к модулю "Вычисление реберной связности графа"

**Модуль подготовил: Гребенников Дмитрий Алексеевич 2384**

# Реберная связность графа

Реберная связность графа (англ. edge connectivity) – это минимальное количество рёбер,
которые необходимо удалить из графа, чтобы он стал несвязным. 
Если граф изначально является несвязным, то его реберная связность равна нулю. 
Для вычисления реберной связности графа используется алгоритм, который перебирает все возможные комбинации рёбер и 
проверяет, становится ли граф несвязным после их удаления.

# Алгоритм вычисления реберной связности

1. Проверка связности графа: Вначале проверяем, является ли граф связным. Если граф не является связным, его реберная связность равна 0.
2. Перебор комбинаций рёбер: Затем перебираем все возможные комбинации рёбер. Сначала проверяем все комбинации одного ребра, затем двух рёбер и т.д.
3. Удаление рёбер: Для каждой комбинации рёбер создаём копию графа и удаляем из неё выбранные рёбра.
4. Проверка связности нового графа: Проверяем, остаётся ли граф связным после удаления рёбер. Если граф становится несвязным, фиксируем количество удалённых рёбер как реберную связность.

# Пояснения к коду:

1. execute(Graph graph)Запускает выполнение модуля. Если граф несвязный или не содержит рёбер, возвращает 0. Иначе вызывает функцию edgeConnectivity для вычисления реберной связности.
2. edgeConnectivity(Graph graph)
   Вычисляет реберную связность графа, перебирая все возможные комбинации рёбер и проверяя, остаётся ли граф связным после удаления каждой комбинации.
3. generateCombinations(List<Edge> edges, int k)
   Генерирует все возможные комбинации k рёбер из списка рёбер.
4. removeEdges(Graph graph, List<Edge> edgesToRemove)
   Создаёт копию графа и удаляет из неё указанные рёбра.
5. Метод isConnected: Проверяет, является ли граф связным, используя обход в глубину (DFS).

Реберная связность графа позволяет понять, насколько граф устойчив к удалению рёбер. Алгоритм, описанный выше, эффективно вычисляет это значение, перебирая все возможные комбинации рёбер и проверяя связность графа на каждом шагу.